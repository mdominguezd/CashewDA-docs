"use strict";(self.webpackChunkcashew_da_docs=self.webpackChunkcashew_da_docs||[]).push([[110],{5091:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var s=t(5893),a=t(1151);const i={},o=void 0,r={id:"Dataset/DataGathering",title:"DataGathering",description:"Brief description of the submodule",source:"@site/docs/Dataset/DataGathering.md",sourceDirName:"Dataset",slug:"/Dataset/DataGathering",permalink:"/CashewDA-docs/docs/Dataset/DataGathering",draft:!1,unlisted:!1,editUrl:"https://github.com/${organizationName}/${projectName}/tree/main/docs/Dataset/DataGathering.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Dataset",permalink:"/CashewDA-docs/docs/category/dataset"},next:{title:"DatasetSplit",permalink:"/CashewDA-docs/docs/Dataset/DatasetSplit"}},d={},l=[{value:"Brief description of the submodule",id:"brief-description-of-the-submodule",level:2},{value:"perform_KMeans()",id:"perform_kmeans",level:2},{value:"Params",id:"params",level:3},{value:"Outputs",id:"outputs",level:3},{value:"Dependencies used",id:"dependencies-used",level:3},{value:"Source code",id:"source-code",level:3},{value:"get_img_n_bounds()",id:"get_img_n_bounds",level:2},{value:"Params",id:"params-1",level:3},{value:"Outputs",id:"outputs-1",level:3},{value:"Dependencies used",id:"dependencies-used-1",level:3},{value:"Source code",id:"source-code-1",level:3},{value:"append_label()",id:"append_label",level:2},{value:"Inputs",id:"inputs",level:3},{value:"Outputs:",id:"outputs-2",level:3},{value:"Dependencies used",id:"dependencies-used-2",level:3},{value:"Source code",id:"source-code-2",level:3},{value:"get_point_distance()",id:"get_point_distance",level:2},{value:"Params",id:"params-2",level:3},{value:"Outputs",id:"outputs-3",level:3},{value:"Source code",id:"source-code-3",level:3},{value:"getRequests()",id:"getrequests",level:2},{value:"Params",id:"params-3",level:3},{value:"Outputs",id:"outputs-4",level:3},{value:"Dependencies used",id:"dependencies-used-3",level:3},{value:"Source code",id:"source-code-4",level:3},{value:"getResult()",id:"getresult",level:2},{value:"Params",id:"params-4",level:3},{value:"Outputs",id:"outputs-5",level:3},{value:"Source code",id:"source-code-5",level:3},{value:"How to run the script",id:"how-to-run-the-script",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"brief-description-of-the-submodule",children:"Brief description of the submodule"}),"\n",(0,s.jsxs)(n.p,{children:["The process followed to get the dataset used for the analysis can be found ",(0,s.jsx)(n.a,{href:"https://github.com/mdominguezd/DomainAdaptationCashewCropMapping_MGIThesis/tree/main/02_Data_Gathering",children:"here"}),". However, this submodule can be used to perform the same process faster. Here, we download 256x256 images directly from google earth engine to the local machine. The script is inspired on the publication ",(0,s.jsx)(n.a,{href:"https://gorelick.medium.com/fast-er-downloads-a2abd512aa26",children:"Fast(er) Downloads"})," from ",(0,s.jsx)(n.a,{href:"https://gorelick.medium.com/",children:"Noel Gorelick"}),". This method makes use of the ",(0,s.jsx)(n.a,{href:"https://developers.google.com/earth-engine/cloud/highvolume",children:"high volume API"})," from google earth engine."]}),"\n",(0,s.jsx)(n.h2,{id:"perform_kmeans",children:"perform_KMeans()"}),"\n",(0,s.jsx)(n.p,{children:"Function to divide a geojson using the K-Means clustering algorithm and return one of the clusters."}),"\n",(0,s.jsx)(n.h3,{id:"params",children:"Params"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"geo_fn:"})," (str) Filename of the geojson"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"chunks:"})," (int) Number of chunks in which the geojson will be divided."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"get_iter:"})," (int) Number of the chunk that will be returned by the function."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"split:"})," (str) Split of the dataset. It can be either train, validation or test."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"outputs",children:"Outputs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"gdf"})," (geopandas.GeoDataFrame) GeoDataFrame subset of the original geojson."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dependencies-used",children:"Dependencies used"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from sklearn.cluster import KMeans\nimport geopandas as gpd\nimport pandas as pd\n"})}),"\n",(0,s.jsx)(n.h3,{id:"source-code",children:"Source code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def perform_KMeans(geo_fn, chunks, get_iter = 0, split = 'train'):\n    \"\"\"\n        Function to divide a geojson using the K-Means clustering algorithm and return one of the clusters.\n\n        Inputs: \n            - geo_fn: (str) Filename of the geojson\n            - chunks: (int) Number of chunks in which the geojson will be divided.\n            - get_iter: (int) Number of the chunk that will be returned by the function.\n            - split: (str) Split of the dataset. It can be either train, validation or test.\n\n        Output:\n            - gdf: (geopandas.GeoDataFrame) GeoDataFrame subset of the original geojson.\n            \n    \"\"\"\n    gdf = gpd.read_file(geo_fn)\n\n    gdf = gdf[gdf['split'] == split]\n    \n    kmeans = KMeans(chunks, random_state = 10)\n    centroids = pd.DataFrame([gdf.centroid.x, gdf.centroid.y]).T\n    labels = kmeans.fit_predict(centroids)\n    \n    gdf = gdf[labels == get_iter]\n\n    gdf['cashew'] = 1\n\n    return gdf\n"})}),"\n",(0,s.jsx)(n.h2,{id:"get_img_n_bounds",children:"get_img_n_bounds()"}),"\n",(0,s.jsx)(n.h3,{id:"params-1",children:"Params"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"gdf:"})," (geopandas.GeoDataFrame) GeoDataFrame subset of the original geojson. This is the resulting gdf from ",(0,s.jsx)(n.a,{href:"../Dataset/DataGathering#perform_kmeans",children:"perform_KMeans()"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"outputs-1",children:"Outputs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"image:"})," (ee.Image) Image that will be downloaded in smaller patches."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"bound:"})," (ee.Geometry) Region of the image that will be downloaded. This geometry will be used to get the central points of the patches."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dependencies-used-1",children:"Dependencies used"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import ee\nimport pandas as pd\n"})}),"\n",(0,s.jsx)(n.h3,{id:"source-code-1",children:"Source code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def get_img_n_bounds(gdf):\n    \"\"\"\n        Function to get the ee.Image and the area of interest. These are the ones that will be downloaded in smaller patches.\n\n        Inputs:\n            - gdf: (geopandas.GeoDataFrame) GeoDataFrame subset of the original geojson.\n\n        Outputs:\n            - image: (ee.Image) Image that will be downloaded in smaller patches.\n            - bound: (ee.Geometry) Region of the image that will be downloaded. This geometry will be used to get the central points of the patches.\n    \"\"\"\n\n    params = pd.read_table('Track_params.txt', delimiter = ', ', engine='python')\n    \n    for i in range(len(params)):\n        globals()[params['Param'].iloc[i]] = params['value'].iloc[i]\n    \n    Pl = (ee.ImageCollection(platform)\n          .filterDate(date_beg, date_end)\n          .select(['B','G','R', 'N'])\n          )\n    \n    bound = ee.Geometry.BBox(*tuple(gdf.dissolve().bounds.iloc[0])).buffer(2000)\n    \n    images = Pl.map(lambda img : img.clip(bound))\n\n    proj = images.first().projection()\n    \n    image = images.median().reproject(proj.getInfo()['crs'], proj.getInfo()['transform'])\n\n    return image, bound\n"})}),"\n",(0,s.jsx)(n.h2,{id:"append_label",children:"append_label()"}),"\n",(0,s.jsx)(n.p,{children:"Function to append the labels (Ground truths) as an additional band to the image that will be downloaded."}),"\n",(0,s.jsx)(n.h3,{id:"inputs",children:"Inputs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"img:"})," (ee.Image) Image gotten from GEE that will be downloaded."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"gdf:"})," (geopandas.GeoDataFrame) Geodataframe with the labels that will be appended."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"outputs-2",children:"Outputs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"image_with_labels:"})," (ee.Image) Image with an extra band in which the labels have been appended."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dependencies-used-2",children:"Dependencies used"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import ee\nimport geemap\n"})}),"\n",(0,s.jsx)(n.h3,{id:"source-code-2",children:"Source code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def append_label(img, gdf):\n    \"\"\"\n        Function to append the labels (Ground truths) as an additional band to the image that will be downloaded.\n\n        Inputs:\n            - img: (ee.Image) Image gotten from GEE that will be downloaded. \n            - gdf: (geopandas.GeoDataFrame) Geodataframe with the labels that will be appended.\n\n        Outputs:\n            - image_with_labels: (ee.Image) Image with an extra band in which the labels have been appended.\n    \"\"\"\n    feat = geemap.geopandas_to_ee(gdf)\n\n    rasterized = feat.reduceToImage(['cashew'], ee.Reducer.max())\n\n    reprojected = rasterized.reproject(img.projection().getInfo()['crs'], img.projection().getInfo()['transform'])\n\n    image_with_labels = img.addBands(reprojected)\n    \n    return image_with_labels\n"})}),"\n",(0,s.jsx)(n.h2,{id:"get_point_distance",children:"get_point_distance()"}),"\n",(0,s.jsx)(n.p,{children:"Function to get distance between centroids of patches that will be downloaded. This value will depend on the percentage of overlap desired."}),"\n",(0,s.jsx)(n.h3,{id:"params-2",children:"Params"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"overlap:"})," (float) Percentage of overlap (Number between 0 and 1)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"outputs-3",children:"Outputs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"distance:"})," (float) Distance between centroids of patches."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"source-code-3",children:"Source code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def get_point_distance(overlap = 0.5):\n    """\n        Function to get distance between centroids of patches that will be downloaded. This value will depend on the percentage of overlap desired.\n\n        Inputs:\n            - overlap: (float) Percentage of overlap (Number between 0 and 1)\n\n        Outputs:\n            - distance: (float) Distance between centroids of patches.\n            \n    """\n    \n    distance = 4.77*256*(1-overlap)\n    \n    return distance\n'})}),"\n",(0,s.jsx)(n.h2,{id:"getrequests",children:"getRequests()"}),"\n",(0,s.jsx)(n.p,{children:"Function to get the centroids of all of the patches that will be downloaded."}),"\n",(0,s.jsx)(n.h3,{id:"params-3",children:"Params"}),"\n",(0,s.jsx)(n.h3,{id:"outputs-4",children:"Outputs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"points"})," (dict) Dictionary with the coordinates of the centroids"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dependencies-used-3",children:"Dependencies used"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import ee\n"})}),"\n",(0,s.jsx)(n.h3,{id:"source-code-4",children:"Source code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def getRequests():\n    \"\"\"\n        Function to get the centroids of all of the patches that will be downloaded.\n\n        Inputs:\n            -\n\n        Outputs:\n            - point: (dict) Dictionary with the coordinates of the centroids\n    \"\"\"\n    proj = image.select([0]).projection()\n\n    latlon = ee.Image.pixelLonLat()\n    \n    coords = latlon.select(['longitude', 'latitude']).reduceRegion(ee.Reducer.toList(), region, distance)\n    lat = ee.List(coords.get('latitude'))\n    lon = ee.List(coords.get('longitude'))\n    \n    point_list = lon.zip(lat)\n    points = ee.FeatureCollection(point_list.map(lambda point : ee.Feature(ee.Geometry.Point(point))))\n\n    buffs = points.map(lambda point : point.buffer(params['buffer'])).filterBounds(feat)\n\n    points = points.filterBounds(buffs)\n    points = points.aggregate_array('.geo').getInfo()\n    \n    return points\n"})}),"\n",(0,s.jsx)(n.h2,{id:"getresult",children:"getResult()"}),"\n",(0,s.jsx)(n.p,{children:"Function to get the download url of the image from GEE and download it."}),"\n",(0,s.jsx)(n.h3,{id:"params-4",children:"Params"}),"\n",(0,s.jsx)(n.h3,{id:"outputs-5",children:"Outputs"}),"\n",(0,s.jsx)(n.h3,{id:"source-code-5",children:"Source code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"@retry(tries=10, delay=1, backoff=2)\ndef getResult(index, point):\n    point = ee.Geometry.Point(point['coordinates'])\n    region = point.buffer(params['buffer']).bounds()\n\n    if params['format'] in ['png', 'jpg']:\n        url = image.getThumbURL(\n            {\n                'region': region,\n                'dimensions': params['dimensions'],\n                'format': params['format'],\n            }\n        )\n    else:\n        url = image.getDownloadURL(\n            {\n                'region': region,\n                'dimensions': params['dimensions'],\n                'format': params['format'],\n            }\n        )\n\n    if params['format'] == \"GEO_TIFF\":\n        ext = 'tif'\n    else:\n        ext = params['format']\n\n    r = requests.get(url, stream=True)\n    if r.status_code != 200:\n        r.raise_for_status()\n\n    out_dir = os.path.abspath(params['out_dir'])\n    basename = str(index+init_ind).zfill(5)\n    filename = f\"{out_dir}/{params['prefix']}{basename}.{ext}\"\n    with open(filename, 'wb') as out_file:\n        shutil.copyfileobj(r.raw, out_file)\n    print(\"Done: \", basename)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"how-to-run-the-script",children:"How to run the script"}),"\n",(0,s.jsx)(n.p,{children:"In order to run this script it is necessary to follow some guidelines."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["All code related to the parallellization of the image download, should be the only code inside the ",(0,s.jsx)(n.code,{children:"if __name__ == '__main__':"})," section.\n",(0,s.jsx)(n.strong,{children:"e.g."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"if __name__ == '__main__':\n  logging.basicConfig()\n  items = getRequests()\n  \n  pool = multiprocessing.Pool(params['processes'])\n  pool.starmap(getResult, enumerate(items))\n  \n  pool.close()\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["The functions to get the images and the region of interested (All except, getRequests and getResult). Need to be run in the script, outside the ",(0,s.jsx)(n.code,{children:"if __name__ == '__main__':"})," section.","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"  geo_fn = 'example.geojson'\n  split = 'train'\n  \n  init_ind = 0\n  \n  if 'TNZ' in geo_fn:\n      domain = 'Tanzania'\n  else:\n      domain = 'IvoryCoast'\n  \n  fold = geo_fn.split('.')[-2][-1]\n  \n  gdf = perform_KMeans(geo_fn, 4, 0, split)\n  \n  feat = geemap.geopandas_to_ee(gdf)\n  \n  image, region = get_img_n_bounds(gdf)\n  \n  image = append_label(image, gdf)\n  \n  distance = get_point_distance(0.8)\n  \n  params = {\n  'buffer': (4.77*256)//2,  # The buffer distance (m) around each point\n  'scale': 100,  # The scale to do stratified sampling\n  'seed': 1,  # A randomization seed to use for subsampling.\n  'dimensions': '256x256',  # The dimension of each image chip\n  'format': \"GEO_TIFF\",  # The output image format, can be png, jpg, ZIPPED_GEO_TIFF, GEO_TIFF, NPY\n  'prefix': domain+'_'+split+'_imgs_',  # The filename prefix\n  'processes': 16,  # How many processes to used for parallel processing\n  'out_dir': 'Chips/'+domain+'/fold'+fold+'/'+split,  # The output directory. Default to the current working directly\n  }\n"})}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>o});var s=t(7294);const a={},i=s.createContext(a);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);