"use strict";(self.webpackChunkcashew_da_docs=self.webpackChunkcashew_da_docs||[]).push([[120],{7265:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var t=n(5893),a=n(1151);const s={},i=void 0,o={id:"Validate/domain_adaptation_performance",title:"domain_adaptation_performance",description:"Brief description of the submodule",source:"@site/docs/Validate/domain_adaptation_performance.md",sourceDirName:"Validate",slug:"/Validate/domain_adaptation_performance",permalink:"/CashewDA-docs/docs/Validate/domain_adaptation_performance",draft:!1,unlisted:!1,editUrl:"https://github.com/${organizationName}/${projectName}/tree/main/docs/Validate/domain_adaptation_performance.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Validate",permalink:"/CashewDA-docs/docs/category/validate"}},c={},d=[{value:"Brief description of the submodule",id:"brief-description-of-the-submodule",level:2},{value:"cosine_sim()",id:"cosine_sim",level:2},{value:"Params",id:"params",level:3},{value:"Outputs",id:"outputs",level:3},{value:"Dependencies",id:"dependencies",level:3},{value:"Source code",id:"source-code",level:3},{value:"euc_dist()",id:"euc_dist",level:2},{value:"Params",id:"params-1",level:3},{value:"Ouptuts",id:"ouptuts",level:3},{value:"Dependencies used",id:"dependencies-used",level:3},{value:"Source code",id:"source-code-1",level:3},{value:"get_features_extracted()",id:"get_features_extracted",level:2},{value:"Params",id:"params-2",level:3},{value:"Outputs",id:"outputs-1",level:3},{value:"Dependencies used",id:"dependencies-used-1",level:3},{value:"Source code",id:"source-code-2",level:3},{value:"tSNE_source_n_target()",id:"tsne_source_n_target",level:2},{value:"Params",id:"params-3",level:3},{value:"Dependencies used",id:"dependencies-used-2",level:3},{value:"Source code",id:"source-code-3",level:3}];function u(e){const r={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h2,{id:"brief-description-of-the-submodule",children:"Brief description of the submodule"}),"\n",(0,t.jsx)(r.p,{children:"In this submodule the code used for evaluating the performance of the domain adaptation methods is explained."}),"\n",(0,t.jsx)(r.h2,{id:"cosine_sim",children:"cosine_sim()"}),"\n",(0,t.jsx)(r.p,{children:"Function to calculate cosine simmilarity between features extracted in source and target domain."}),"\n",(0,t.jsx)(r.h3,{id:"params",children:"Params"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"source_F: Features extracted from source domain"}),"\n",(0,t.jsx)(r.li,{children:"target_F: Features extracted from target domain"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"outputs",children:"Outputs"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"cos: Mean cosine similarity between features extracted on both domains."}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"dependencies",children:"Dependencies"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-py",children:"from torch import nn\n"})}),"\n",(0,t.jsx)(r.h3,{id:"source-code",children:"Source code"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-py",children:'def cosine_sim(source_F, target_F):\r\n    """\r\n        Function to calculate cosine simmilarity between features extracted in source and target domain.\r\n\r\n        Input\r\n            - source_F: Features extracted from source domain\r\n            - target_F: Features extracted from target domain\r\n\r\n        Output:\r\n            - cos: Numeric value of cosine similarity\r\n    """\r\n\r\n    COS = nn.CosineSimilarity(dim = 1, eps = 1e-6)\r\n    \r\n    cos = COS(torch.tensor(source_F), torch.tensor(target_F)).mean()\r\n\r\n    return cos.numpy()\n'})}),"\n",(0,t.jsx)(r.h2,{id:"euc_dist",children:"euc_dist()"}),"\n",(0,t.jsx)(r.p,{children:"Function to calculate de euclidean distance between a vector of features extracted from source and target domain."}),"\n",(0,t.jsx)(r.h3,{id:"params-1",children:"Params"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"source_F: Features extracted from source domain"}),"\n",(0,t.jsx)(r.li,{children:"target_F: Features extracted from target domain"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"ouptuts",children:"Ouptuts"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"euc_dist: Numeric value of eulidean distance"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"dependencies-used",children:"Dependencies used"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-py",children:"import torch\n"})}),"\n",(0,t.jsx)(r.h3,{id:"source-code-1",children:"Source code"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-py",children:'def euc_dist(source_F, target_F):\r\n    """\r\n        Function to calculate de euclidean distance between vector of features extracted from source and target domain.\r\n\r\n        Input:\r\n            - source_F: Features extracted from source domain\r\n            - target_F: Features extracted from target domain\r\n        \r\n        Output:\r\n            - euc_dist: Numeric value of eulidean distance\r\n    """\r\n    \r\n    source_F = torch.tensor(source_F)\r\n    target_F = torch.tensor(target_F)\r\n    \r\n    euc_dist = torch.cdist(source_F, target_F).mean()\r\n\r\n    return euc_dist\n'})}),"\n",(0,t.jsx)(r.h2,{id:"get_features_extracted",children:"get_features_extracted()"}),"\n",(0,t.jsx)(r.p,{children:"Function to get the features extrcted from a specific neural network on both the source and target domain."}),"\n",(0,t.jsx)(r.h3,{id:"params-2",children:"Params"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"source_domain: Source domain from which the features will be extracted"}),"\n",(0,t.jsx)(r.li,{children:"target_domain: Target domain from which the features will be extracted"}),"\n",(0,t.jsx)(r.li,{children:"DS_args: List of arguments of the dataset of bothe the source and target domain (i.e. [batch_size, transforms, normalization, Vegetation_Indices, Only_DS True if model has DA])"}),"\n",(0,t.jsx)(r.li,{children:"network: Torch network"}),"\n",(0,t.jsx)(r.li,{children:"network_filename: Filename of the model to be used."}),"\n",(0,t.jsx)(r.li,{children:"Love: Boolean to indicate the use of LoveDA dataset"}),"\n",(0,t.jsx)(r.li,{children:"cos_int: Boolean to indicate if the calculation of cosine similarity should be done on the go"}),"\n",(0,t.jsx)(r.li,{children:"euc_int: Boolean to indicate if the calculation of euclidean distance should be done on the go"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"outputs-1",children:"Outputs"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Either a metric if cos_int or euc_int are not False"}),"\n",(0,t.jsx)(r.li,{children:"Or the Features extracted and sample images"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"dependencies-used-1",children:"Dependencies used"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-py",children:"import torch\r\nfrom tqdm import tqdm\r\nimport numpy as np\r\n\r\nfrom Dataset.ReadyToTrain_DS import get_LOVE_DataLoaders, get_DataLoaders\r\nfrom utils import get_training_device\n"})}),"\n",(0,t.jsx)(r.h3,{id:"source-code-2",children:"Source code"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-py",children:"device = get_training_device()\r\n\r\n    if network == None:\r\n        network = torch.load(network_filename, map_location = device) \r\n    \r\n    if Love:\r\n        source_loaders = get_LOVE_DataLoaders(source_domain, *DS_args)\r\n        target_loaders = get_LOVE_DataLoaders(target_domain, *DS_args)\r\n\r\n    else:\r\n        source_loaders = get_DataLoaders(source_domain, *DS_args)\r\n        target_loaders = get_DataLoaders(target_domain, *DS_args)\r\n\r\n    n_batches = min(len(source_loaders[0]), len(target_loaders[0])) \r\n\r\n    batches = enumerate(zip(source_loaders[0], target_loaders[0]))\r\n\r\n    cos = 0\r\n\r\n    if cos_int or euc_int:\r\n        d = 'Calculating distance metric'\r\n    else:\r\n        d = 'Getting features extracted'\r\n\r\n    num_imgs = 4\r\n    \r\n    for i in tqdm(range(n_batches), desc = d):\r\n\r\n        k, (source, target) = next(batches)\r\n\r\n        if Love:\r\n            source_input = LOVE_resample_fly(source['image']).to(device)\r\n            target_input = LOVE_resample_fly(target['image']).to(device)  \r\n        else:\r\n            source_input = source[0].to(device)\r\n            target_input = target[0].to(device)\r\n        \r\n        max_batch_size = np.min([source_input.shape[0], target_input.shape[0]])\r\n\r\n        s_features = network.FE(source_input)[:max_batch_size].flatten(start_dim = 1).cpu().detach().numpy()\r\n        t_features = network.FE(target_input)[:max_batch_size].flatten(start_dim = 1).cpu().detach().numpy()\r\n\r\n        if i == 0:\r\n            s_imgs = source_input[:num_imgs]\r\n            # s_feats = s_features[:num_imgs]\r\n            t_imgs = target_input[:num_imgs]\r\n            # t_feats = t_features[:num_imgs]\r\n\r\n        if cos_int:\r\n            cos += cosine_sim(s_features, t_features)\r\n        elif euc_int:\r\n            cos += euc_dist(s_features, t_features)\r\n        else:\r\n            if i == 0:\r\n                source_F = np.array(s_features)\r\n                target_F = np.array(t_features)\r\n            else:\r\n                source_F = np.append(source_F, s_features, axis = 0)\r\n                target_F = np.append(target_F, t_features, axis = 0)\r\n                \r\n\r\n    cos /= n_batches\r\n    \r\n    if cos_int or euc_int:\r\n        return cos\r\n    else:\r\n        return source_F, target_F, s_imgs, t_imgs\n"})}),"\n",(0,t.jsx)(r.h2,{id:"tsne_source_n_target",children:"tSNE_source_n_target()"}),"\n",(0,t.jsx)(r.p,{children:"Function to visualize the features extracted for source and target domains."}),"\n",(0,t.jsx)(r.h3,{id:"params-3",children:"Params"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"source_F: Features extracted from source domain"}),"\n",(0,t.jsx)(r.li,{children:"target_F: Features extracted from target domain"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"dependencies-used-2",children:"Dependencies used"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-py",children:"from sklearn.manifold import TSNE\r\nimport numpy as np\r\nimport seaborn as sns\r\nimport matplotlib.pyplot as plt\n"})}),"\n",(0,t.jsx)(r.h3,{id:"source-code-3",children:"Source code"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-py",children:"def tSNE_source_n_target(source_F, target_F):\r\n    \"\"\"\r\n        Function to visualize the features extracted for source and target domains.\r\n    \"\"\"\r\n\r\n    X = np.append(source_F[:, :200000], target_F[:, :200000], axis = 0)\r\n    \r\n    domains = ['Source'] * source_F.shape[0] + ['Target'] * target_F.shape[0]\r\n    \r\n    comps = 2\r\n\r\n    tsne = TSNE(comps, random_state = 123, perplexity = 50)\r\n\r\n    tsne_X = tsne.fit_transform(X)\r\n\r\n    fig, ax = plt.subplots(1,1,figsize = (7,4.5))\r\n\r\n    sns.scatterplot(x = tsne_X[:,0], y = tsne_X[:,1], hue = domains, ax = ax, palette = ['darkblue', 'darkred'])\r\n\r\n    plt.tight_layout()\r\n\r\n    fig.savefig('t_SNE_simple.png', dpi = 200)\r\n    \r\n    for i in range(4):\r\n        ax.scatter(x = tsne_X[i,0], y = tsne_X[i,1], s = 250, c = 'blue', zorder = -1)\r\n        ax.text(x = tsne_X[i,0], y = tsne_X[i,1], s = str(i+1), color = 'white')\r\n        ax.scatter(x = tsne_X[source_F.shape[0] + i,0], y = tsne_X[source_F.shape[0] + i,1], s = 250, c = 'red', zorder = -1)\r\n        ax.text(x = tsne_X[source_F.shape[0] + i,0], y = tsne_X[source_F.shape[0]+ i,1], s = str(i+1), color = 'white')\r\n\r\n    plt.tight_layout()\r\n\r\n    fig.savefig('t_SNE.png', dpi = 200)\r\n\r\n    return tsne_X\n"})})]})}function l(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},1151:(e,r,n)=>{n.d(r,{Z:()=>o,a:()=>i});var t=n(7294);const a={},s=t.createContext(a);function i(e){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);